
<!--
// TODO: (remove items when completed)
//
//3. Apply BrushFire Algorithm
//4. make controllers, drawing and bfs sections.
//
//6. Draw the array values on the screen (Debug Draw)
////////////////////////////////////////////////////////////description//
// We want to control variance and mean position and find a way to the goal.
/////////////////////////////////////////////////////////////////////////
//
// Author: Shiva Shahrocki and Aaron Becker
// Started" 11/01/2014 -- present
// Description: controls the mean position of n holonomic disk robots using mean position as feedback
/// uses a PD controller.
//
// Records output into a log file/
//
// Status {working, broken, in progress, replacedby}: broken: controller works, but log files are not yet working
//
///////////////////////////////////////////////////////////////////////////////
-->
<html>
	<link rel="ensemble icon" href="pictures/ATBensembleIcon.ico">
	<head>
		<title>StochasticSwarmControl</title>
	</head>
	<body onload="init();">
		<canvas id="canvas" width="600" height="600" style="background-color:#EEEEEE;" cols="20" rows="20"></canvas>
		<div id="cc"></div>
	</body>
	<script type="text/javascript" src="../shared/Box2dWeb-2.1.a.3.min.js"></script> <!-- box2d -->
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script> <!-- forms & strings -->
	<script type="text/javascript" src="../shared/jcanvas.min.js"></script>
	<script type="text/javascript">
		// in Chrome, to view the console: Use the keyboard shortcut Command - Option - J (Mac) or Control -Shift -J (Windows/Linux).


		///////////////////////////////
		//Begin Global Variables
		///////////////////////////////
		var ROBOT_INPUT = {
			ROBOT_IDLE : 0x0,
			ROBOT_PROP : 0x01, //proportional control
			WAIT : 0x40
		};
		var m_ControlInputY = 0;
		var goalX = 16;
		var goalY = 20;
		var m_controlState = ROBOT_INPUT.ROBOT_IDLE;
		var mapXSize = 20;
		var mapYSize = 20;
		var map = new Array(mapXSize);
		var ifBFS = false;
		for (var i = 0; i < mapXSize; i++) 
		{
			map[i] = new Array(mapYSize);
		}


		/////////////////////////////
		//End Global Variables
		/////////////////////////////

		/////////////////////////////
		//Begin Algorithmic Functions
		/////////////////////////////

		// It does BFS
		function BFS(x, y )
		{
			var dist = map[x][y];
			if(dist == -1)
			{
				return;
			}
			if(x-1 >0)
			{
				if(map[x-1][y] > dist +1)
				{
					map[x-1][y] = dist+1;
					//console.log("with " + x-1 + " and " + y + " We have : " + map[x-1][y]);
					BFS(x-1, y);
				}
			}
			else
			{
				return;
			}
			if(y+1 < mapYSize)
			{
				if(map[x][y+1] > dist +1)
				{
					map[x][y+1] = dist+1;
					//console.log("with " + x + " and " + y +1+ " We have : " + map[x][y+1]);
					BFS(x, y+1);
				}
			}
			else
			{
				return;
			}
			if(y-1 >0)
			{
				if(map[x][y-1] > dist +1)
				{
					map[x][y-1] = dist+1;
					//console.log("with " + x + " and " + y-1 + " We have : " + map[x][y-1]);
					BFS(x, y-1);
				}
			}
			else
			{
				return;
			}
			if(x+1 < mapXSize)
			{
				if(map[x+1][y] > dist +1)
				{
					map[x+1][y] = dist+1;
					//console.log("with " + x+1 + " and " + y + " We have : " + map[x+1][y]);
					BFS(x+1, y);
				}
			}
			else
			{
				return;
			}

		}

		////////////////////////////
		//End Algorithmic Functions
		////////////////////////////

		////////////////////////////
		//Begin Controller Functions
		////////////////////////////

		////////////////////////////
		//End Controller Functions
		////////////////////////////

		///////////////////////////
		//Begin Drawing Functions
		///////////////////////////


		///////////////////////////
		//End Drawing Functions
		///////////////////////////

		///////////////////////////
		//Begin Debug Functions
		///////////////////////////

		///////////////////////////
		//End Debug Functions
		///////////////////////////

		function init() 
		{
			var b2Vec2 = Box2D.Common.Math.b2Vec2
				, b2AABB = Box2D.Collision.b2AABB
				, b2BodyDef = Box2D.Dynamics.b2BodyDef
				, b2Body = Box2D.Dynamics.b2Body
				, b2FixtureDef = Box2D.Dynamics.b2FixtureDef
				, b2Fixture = Box2D.Dynamics.b2Fixture
				, b2World = Box2D.Dynamics.b2World
				, b2MassData = Box2D.Collision.Shapes.b2MassData
				, b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape
				, b2CircleShape = Box2D.Collision.Shapes.b2CircleShape
				, b2DebugDraw = Box2D.Dynamics.b2DebugDraw
				, b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef
			;
			var world = new b2World(
				new b2Vec2(0, 00) //gravity setting to zero removes gravity
				, true //allow sleep
			);
			var canvas = $('#canvas');
			var context = canvas.get(0).getContext('2d');
			var timeStart = null;
			var timeFinish = null;
			var timer = null;
			var passed = null;
			var overall_time = null;
			var firstloop = false;
			var boundaryHeight = 2;
			var boundaryWidth = 20;

			
			var fixDef = new b2FixtureDef;
			fixDef.density = 1.0;
			fixDef.friction = 0.5;
			fixDef.restitution = 0.2; //bouncing value
			var bodyDef = new b2BodyDef;

			//create enclosing boundary rectangles
			bodyDef.userData = 'obstacle';
			bodyDef.type = b2Body.b2_staticBody;
			fixDef.shape = new b2PolygonShape;
			fixDef.shape.SetAsBox(20, 2);//width, height
			bodyDef.position.Set(10, 600 / 30 + 1); //bottom
			var bodyBottom = world.CreateBody(bodyDef);
			bodyBottom.CreateFixture(fixDef);
			bodyDef.position.Set(10, -1); //top
			world.CreateBody(bodyDef).CreateFixture(fixDef);
			fixDef.shape.SetAsBox(2, 14);//width, height
			bodyDef.position.Set(-1, 13); //left
			world.CreateBody(bodyDef).CreateFixture(fixDef);
			bodyDef.position.Set(21, 13); // right side
			world.CreateBody(bodyDef).CreateFixture(fixDef);


			// maze
			bodyDef.userData = 'obstacle';
	 		fixDef.shape.SetAsBox(10, 0.5);//width, height
	        bodyDef.position.Set(15, 150 / 30 + 1.5); //TOP
	        var bodyBottom = world.CreateBody(bodyDef);
	        bodyBottom.CreateFixture(fixDef);
	 
	        bodyDef.position.Set(5, 400 / 30 + 0.2); //BOTTOM
	        world.CreateBody(bodyDef).CreateFixture(fixDef);



			//create an object to move
			bodyDef.type = b2Body.b2_dynamicBody;
			fixDef.density = 10.0;
			fixDef.friction = 0.5;
	        fixDef.restitution = 0.2;  //bouncing value
	        bodyDef.position.Set(7,17.5);
	        bodyDef.userData = 'moveable';
	        fixDef.shape = new b2PolygonShape;
	        fixDef.shape.SetAsBox(1.5,1.5);
	        var obst = world.CreateBody(bodyDef);
	        obst.CreateFixture(fixDef);
	        obst.m_angularDamping = 0.1;
	        obst.m_linearDamping = 0.1;

			//create the robots
			bodyDef.type = b2Body.b2_dynamicBody;
			var robotrad = 0.2;
			var numrobots = 100;//Math.floor(20/(4*robotrad*robotrad));
			fixDef.density = 1.0;
			fixDef.friction = 0.5;
			fixDef.restitution = 0.2; //bouncing value
			var m_Robot = new Array();
			var rowLength = Math.floor(5/(2*robotrad));
			for(var i = 0; i < numrobots; ++i) 
			{
				fixDef.shape = new b2CircleShape(
					robotrad //Math.random() + 0.1 //radius
				);
				bodyDef.userData = 'robot';
				bodyDef.position.x = 0.5+(i%rowLength)*2*robotrad;
				bodyDef.position.y = 19.5-Math.floor(i/rowLength)*2*robotrad;
				m_Robot[i] = world.CreateBody(bodyDef);
				m_Robot[i].CreateFixture(fixDef);
				m_Robot[i].m_angularDamping = 1;
				m_Robot[i].m_linearDamping = 1;
			}

			window.requestAnimFrame = (function()
			{
				return window.requestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				function(/* function */ callback, /* DOMElement */ element){
					window.setTimeout(callback, 1000 / 60);
				};
			})();

			///////////////////////////////////
			// Brushfire Algorithm
			///////////////////////////////////
			var infinity = mapXSize * mapYSize;
			var mazeSize = 15;
			var mazeTopY = 13;
			var mazeDownY = 6;
			var goalPositionX = 19;
			var goalPositionY = 1;
			//giving -1 to boundaries
			if(!ifBFS)
			{
				for(var i = 0 ; i < mapXSize; i++)
				{
					map[i][0]= -1;
					map[i][mapYSize -1] = -1;
					map[0][i]= -1;
					map[mapXSize-1][i]= -1;
				}
				// giving -1 to obstacles.(Down Maze)
				for (var i = 0 ; i < mazeSize; i++)
				{
					map[i][mazeTopY]= -1;
				}
				//Top Maze
				for(var i = mapXSize-1 ; i > mapXSize- mazeSize; i--)
				{
					map[i][mazeDownY] = -1;
				}
				for (var i = 0 ; i < mapXSize ; i++)
					for (var j = 0 ; j < mapYSize; j++)
					{
						if(map[i][j] != -1)
						{
							map[i][j]= infinity;
						}
					}
				map[goalPositionX][goalPositionY]= 0;
			
				BFS(goalPositionX, goalPositionY);
				for(var i = 0 ; i < mapXSize; i++)
					for (var j = 0 ; j < mapYSize; j++)
					{
						console.log("with " + j + " and " + i + " we have " + map[j][i]);
					}
				ifBFS = true;
			}
			
			(function animloop()
			{
				requestAnimFrame(animloop);
				update();
			})();
			if ( timeStart == null)
			{
				var day = new Date();
				timeStart= day.getTime();
			}
			function lineDistance( x1,y1,x2,y2)
			{
				var xs = 0;
				var ys = 0;
				xs = x1 - x2;
				xs = xs * xs;
				ys = y1- y2;
				ys = ys * ys;
				return Math.sqrt( xs + ys );
			}

			//called each animation round
			//y-axis is inverted in webpage
			function update() 
			{
				var impulseV=new b2Vec2(0,0);
				var impulse = 3.0;
				if(m_controlState & ROBOT_INPUT.ROBOT_PROP)
				{
					impulseV.x = m_ControlInputX;
					impulseV.y = m_ControlInputY;
				}
				//apply Brownian noise:
				for(var i =0; i<m_Robot.length; i++) 
				{
					var brownianImpulse = new b2Vec2(0,0);
					var mag = 0;
					var ang = 0;
					var vary= 1;
					mag = vary * Math.random();
					ang = 2*Math.PI*Math.random();
					brownianImpulse.x = mag*Math.cos(ang) + impulseV.x ;
					brownianImpulse.y = mag*Math.sin(ang) + impulseV.y ;
					m_Robot[i].ApplyForce(brownianImpulse,m_Robot[i].GetWorldPoint(new b2Vec2(0,0)));
				}

			world.Step(1 / 60, 10, 10);
			world.DrawDebugData();
			world.ClearForces();			
			$("canvas").clearCanvas();
			$("canvas")
			.rotateCanvas(
			{
				x: 5 * 30, y: 5 * 30,
				rotate: angle
			})
			.drawArc(
			{
				fillStyle: "orange",
				x: 5 * 30, y: 5 * 30,
				radius: radius * 30
			})
			.restoreCanvas();
			
			
			//draw robots and obstacles
			for (b = world.GetBodyList() ; b; b = b.GetNext())
			{
				var angle = b.GetAngle()*(180/Math.PI);
				for(f = b.GetFixtureList(); f; f = f.GetNext()) 
				{
					if (b.GetUserData() == 'robot')
					{
						var radius = f.GetShape().GetRadius();
						var pos = b.GetPosition();
						$("canvas")
						.rotateCanvas(
						{
							x: pos.x * 30, y: pos.y * 30,
							rotate: angle
						})
						.drawArc(
						{
							strokeStyle: "lightblue",
							strokeWidth: 1,
							fillStyle: "blue",
							x: pos.x * 30, y: pos.y * 30,
							radius: radius * 30
						})
						.restoreCanvas();
					}
					else if (b.GetUserData() == 'obstacle' || b.GetUserData() == 'moveable' || b.GetUserData() == 'rectangle_ground')
					{
						var X = f.GetShape().GetVertices()[1].x - f.GetShape().GetVertices()[0].x;
						var Y = f.GetShape().GetVertices()[2].y - f.GetShape().GetVertices()[1].y;
			
				
			//console.log(X);
			var pos = b.GetPosition();
			var color = 'orange';
			if(b.GetUserData() == 'obstacle')
				color = 'red';
			if(b.GetUserData() == 'moveable')
				color = 'green';
			$("canvas")
			.rotateCanvas({
				x: pos.x * 30, y: pos.y * 30,
				rotate: angle
			})
			.drawRect({
				fillStyle: color,
				x: pos.x * 30, y: pos.y * 30,
				width: X * 30,
				height: Y * 30,
				cornerRadius: 0
			})
			.restoreCanvas();
			for(var i = 0 ; i < 20; i++)
			{
				$("canvas")
				.drawLine({
				strokeStyle: 'gray',
				strokeWidth: 1,
				x1: i*30, y1: 0,
				x2: i*30, y2: 20*30
			})
				.drawLine({
				strokeStyle: 'gray',
				strokeWidth: 1,
				x1: 0, y1: i*30,
				x2: 20*30, y2: i*30
			})
			}
			$("canvas").restoreCanvas();
			
			
		}

		}
		}
			//draw the goal position
			$("canvas").drawArc({
				strokeStyle: "green",
				strokeWidth: 5,
				x: goalX * 30, y: goalY * 30,
				radius: radius * 30
			})
			/*.drawLine({
				strokeStyle: 'green',
				strokeWidth: 3,
				x1: 0, y1: goalY * 30,
				x2: 1000, y2: goalY * 30,
			})
			.drawLine({
				strokeStyle: 'green',
				strokeWidth: 3,
				x1: goalX* 30, y1: 0 ,
				x2: goalX * 30, y2: 1000,
				
			})*/
			.restoreCanvas();
			var day = new Date();
			if( timeFinish == null && false)
				{ timeFinish = day.getTime();}
			if(overall_time == null) // set the start time
			{
				overall_time = day.getTime();
			}
			var elapsedTimeSec = (day.getTime()- overall_time )/1000;
			string = "Time = "+ elapsedTimeSec +"s<br>A PD controller is making robots (blue discs) track a mean vertical position</strong>";
			$('#cc').html(string); //USERDATA WILL SHOWN IN "div" WITH ID "cc"




			/////////////////////////////////////////////////////////////////////////////////////////////////////////////
			// CONTROLLER
			///////////////////////////////////////////////////////////////////////////////////////////////////////////
			//goal positions
			var cycleInSec = 20;
			var amplitudeY = 5;
			var offsetY = 5;
			var amplitudeX = 5;
			var offsetX = 5;
			var max_desired_var_x = 5;
			var min_desired_var_x = 3;
			var desired_var_y = 1;
			var sum_position_x = 0;
			var sum_position_y = 0;
			var sum2_x = 0;
			var sum2_y = 0;
			var desired_var_x;
			//TODO: make this depend on time
			if(var_x < min_desired_var_x)
			{
				goalX = 18;
				goalY = 18;
				desired_var_x = max_desired_var_x;
			}
			else if(var_x > max_desired_var_x)
			{
				goalX = 18;
				goalY = 18;
				desired_var_x = min_desired_var_x;
			}
			//console.log("Var X : " + var_x);


			for(var i = 0; i < numrobots; ++i) {
				sum_position_x += m_Robot[i].GetPosition().x;
				sum_position_y += m_Robot[i].GetPosition().y;
			}
			var mean_position_x = sum_position_x / numrobots;
			var mean_position_y = sum_position_y / numrobots;
			// TODO: follow Knuth's example: http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance
			for(var i = 0; i < numrobots; ++i) {
				sum2_x += (m_Robot[i].GetPosition().x - mean_position_x) * (m_Robot[i].GetPosition().x - mean_position_x);
				sum2_y += (m_Robot[i].GetPosition().y - mean_position_y) * (m_Robot[i].GetPosition().y - mean_position_y);
			}
			var var_x = sum2_x / numrobots;
			var var_y = sum2_y / numrobots;
			//draw the average position
			$("canvas").drawArc({
				strokeStyle: "red",
				strokeWidth: 5,
				x: mean_position_x* 30, y: mean_position_y * 30,
				radius: radius * 30
			})

			/*.drawLine({
				strokeStyle: 'red',
				strokeWidth: 3,
				x1: 0, y1: mean_position_y * 30,
				x2: 1000, y2: mean_position_y* 30,
			})
			.drawLine({
				strokeStyle: 'red',
				strokeWidth: 3,
				x1: mean_position_x*30, y1: 0 ,
				x2: mean_position_x*30, y2: 1000* 30,
			})
			//draw goal variance line
			.drawLine({
				strokeStyle: 'green',
				strokeWidth: 7,
				x1: (mean_position_x - desired_var_x/2)*30, y1:mean_position_y* 30 ,
				x2: (mean_position_x + desired_var_x/2)*30, y2:mean_position_y* 30,
			})
			//draw  variance
			.drawLine({
				strokeStyle: 'pink',
				strokeWidth: 5,
				x1: (mean_position_x - var_x/2)* 30, y1:mean_position_y* 30 ,
				x2: (mean_position_x + var_x/2)* 30, y2:mean_position_y* 30,
			})*/
			.restoreCanvas();


			//goalY = offsetY+ amplitudeY*( elapsedTimeSec%cycleInSec > cycleInSec/2 );
			//goalX = offsetX+ amplitudeX*( elapsedTimeSec%cycleInSec > cycleInSec/2 );
			var Kgain = 4;
			var Kderivative = 1;
			var sum_velocity_x = 0;
			var sum_velocity_y = 0;
			for(var i = 0; i < numrobots; ++i) {
				sum_velocity_x += m_Robot[i].GetLinearVelocity().x;
				sum_velocity_y += m_Robot[i].GetLinearVelocity().y;
			}
			var mean_velocity_x = sum_velocity_x / numrobots;
			var mean_velocity_y = sum_velocity_y / numrobots;
			m_ControlInputY = Kgain*(goalY - mean_position_y) + Kderivative*(0-mean_velocity_y) ;
			m_ControlInputX = Kgain*(goalX - mean_position_x) + Kderivative*(0-mean_velocity_x) ;
			m_controlState= ROBOT_INPUT.ROBOT_PROP;
			//console.log(elapsedTimeSec + " " + mean_position_y + " " + goalY + " " + mean_position_x + " " + goalX );
			}; //end update
		};
	</script>
	<style>
	#cc	{
		top: 600px;
		width: 600px;
		height: 200px;
		margin: 0;
		overflow: auto;
	}
	</style>
	</html>


